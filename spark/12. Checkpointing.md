# 12. Checkpointing ⛓️

**Checkpointing** breaks the lineage and saves the current state to stable storage (HDFS, S3, etc.).

## Use Cases

1. **Long lineage**: Break expensive computation chains
2. **Iterative algorithms**: ML algorithms with many iterations
3. **Streaming**: Stable state for recovery

## Difference from Caching

| Aspect       | Cache                  | Checkpoint                |
| ------------ | ---------------------- | ------------------------- |
| **Storage**  | Memory (default)       | Disk (HDFS, S3)           |
| **Lineage**  | Preserved              | Broken                    |
| **Recovery** | Lost if executor fails | Survives executor failure |
| **Use**      | Short-term performance | Long-term stability       |

## Checkpointing Example

```python
# Setup checkpoint directory
checkpoint_dir = "hdfs://namenode/checkpoints"
spark.sparkContext.setCheckpointDir(checkpoint_dir)

# Long computation with many transformations
df = spark.read.parquet("source.parquet")
df = df.filter(col("amount") > 0)
df = df.withColumn("tax", col("amount") * 0.1)
df = df.join(dimension, "id")
# ... 20 more transformations ...

# Checkpoint to break lineage
df.checkpoint()

# Subsequent operations don't recompute previous chain
result = df.groupBy("category").agg(sum("amount"))

# If executor fails after checkpoint:
# 1. Driver replans remaining operations
# 2. Reads checkpointed data from disk
# 3. Continues from checkpoint (not from beginning)
```

## Eager vs Lazy Checkpoint

```python
# Lazy checkpoint: Breaks lineage but doesn't write immediately
df.checkpoint()

# Write happens when next action is triggered
df.count()  # Triggers checkpoint write

# Eager checkpoint: Immediately writes to storage
df.checkpoint(eager=True)  # Synchronous write, may be slow
```
